"""
Base Strategy Agent - Foundation for all trading strategy agents
"""
import logging
import time
import json
import os
from abc import ABC, abstractmethod
from dataclasses import dataclass, field, asdict
from datetime import datetime
from typing import Optional, List, Dict, Any
from enum import Enum

logger = logging.getLogger(__name__)

class SignalSide(Enum):
    LONG = "long"
    SHORT = "short"
    NEUTRAL = "neutral"

@dataclass
class Signal:
    """Trading signal generated by a strategy"""
    strategy_id: str
    symbol: str
    side: SignalSide
    confidence: float  # 0.0 to 1.0
    price: float
    timestamp: datetime
    reason: str
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    # Risk parameters
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    position_size_pct: float = 1.0  # Percentage of allocated capital

@dataclass
class Position:
    """Open position tracked by agent"""
    id: str
    symbol: str
    side: str  # 'long' or 'short'
    entry_price: float
    current_price: float
    size: float
    value: float
    unrealized_pnl: float
    stop_loss: Optional[float]
    take_profit: Optional[float]
    opened_at: datetime
    strategy_id: str

@dataclass 
class Trade:
    """Completed trade record"""
    id: str
    symbol: str
    side: str
    entry_price: float
    exit_price: float
    size: float
    pnl: float
    pnl_percent: float
    entry_time: datetime
    exit_time: datetime
    strategy_id: str
    close_reason: str

@dataclass
class AgentState:
    """Persistent state for an agent"""
    agent_id: str
    enabled: bool = True
    positions: List[Position] = field(default_factory=list)
    trades: List[Trade] = field(default_factory=list)
    total_pnl: float = 0.0
    win_count: int = 0
    loss_count: int = 0
    last_signal_time: Optional[datetime] = None
    metadata: Dict[str, Any] = field(default_factory=dict)

class BaseStrategyAgent(ABC):
    """
    Base class for all strategy agents.
    Each strategy runs as an independent agent with its own:
    - Signal generation logic
    - Position tracking
    - Risk parameters
    """
    
    def __init__(
        self,
        agent_id: str,
        name: str,
        symbols: List[str],
        config: Dict[str, Any] = None,
        data_dir: str = None
    ):
        self.agent_id = agent_id
        self.name = name
        self.symbols = symbols
        self.config = config or {}
        # Use relative path from this file, or /tmp for cloud
        if data_dir:
            self.data_dir = data_dir
        else:
            this_dir = os.path.dirname(os.path.abspath(__file__))
            self.data_dir = os.path.join(this_dir, '..', 'data', agent_id)
        
        # Ensure data directory exists
        os.makedirs(self.data_dir, exist_ok=True)
        
        # State
        self.state = self._load_state()
        self.enabled = self.state.enabled
        
        # Execution client (set by orchestrator)
        self.execution_client = None
        
        # Logger
        self.logger = logging.getLogger(f"agent.{agent_id}")
    
    def _load_state(self) -> AgentState:
        """Load agent state from disk"""
        state_file = os.path.join(self.data_dir, "state.json")
        if os.path.exists(state_file):
            try:
                with open(state_file, 'r') as f:
                    data = json.load(f)
                    return AgentState(**data)
            except Exception as e:
                self.logger.error(f"Failed to load state: {e}")
        return AgentState(agent_id=self.agent_id)
    
    def _save_state(self):
        """Save agent state to disk"""
        state_file = os.path.join(self.data_dir, "state.json")
        try:
            with open(state_file, 'w') as f:
                # Convert dataclass to dict, handling datetime
                data = asdict(self.state)
                json.dump(data, f, indent=2, default=str)
        except Exception as e:
            self.logger.error(f"Failed to save state: {e}")
    
    @abstractmethod
    def generate_signals(self, market_data: Dict[str, Any]) -> List[Signal]:
        """
        Generate trading signals based on market data.
        Must be implemented by each strategy.
        
        Args:
            market_data: Dict containing OHLCV data for symbols
            
        Returns:
            List of Signal objects
        """
        pass
    
    @abstractmethod
    def get_required_indicators(self) -> List[str]:
        """
        Return list of indicators this strategy needs.
        Used by data fetcher to prepare market data.
        
        Returns:
            List of indicator names (e.g., ['sma_20', 'rsi_14', 'bbands'])
        """
        pass
    
    def should_exit(self, position: Position, current_price: float) -> Optional[str]:
        """
        Check if a position should be closed.
        Override for custom exit logic.
        
        Returns:
            Exit reason string if should exit, None otherwise
        """
        # Default stop-loss check
        if position.stop_loss:
            if position.side == 'long' and current_price <= position.stop_loss:
                return 'stop_loss'
            elif position.side == 'short' and current_price >= position.stop_loss:
                return 'stop_loss'
        
        # Default take-profit check
        if position.take_profit:
            if position.side == 'long' and current_price >= position.take_profit:
                return 'take_profit'
            elif position.side == 'short' and current_price <= position.take_profit:
                return 'take_profit'
        
        return None
    
    def on_position_opened(self, position: Position):
        """Called when a position is opened"""
        self.state.positions.append(position)
        self._save_state()
        self.logger.info(f"Position opened: {position.symbol} {position.side} @ {position.entry_price}")
    
    def on_position_closed(self, position: Position, exit_price: float, reason: str):
        """Called when a position is closed"""
        # Calculate PnL
        if position.side == 'long':
            pnl = (exit_price - position.entry_price) * position.size
        else:
            pnl = (position.entry_price - exit_price) * position.size
        
        pnl_percent = (pnl / position.value) * 100
        
        # Record trade
        trade = Trade(
            id=f"trade-{position.id}",
            symbol=position.symbol,
            side=position.side,
            entry_price=position.entry_price,
            exit_price=exit_price,
            size=position.size,
            pnl=pnl,
            pnl_percent=pnl_percent,
            entry_time=position.opened_at,
            exit_time=datetime.utcnow(),
            strategy_id=self.agent_id,
            close_reason=reason
        )
        self.state.trades.append(trade)
        
        # Update stats
        self.state.total_pnl += pnl
        if pnl > 0:
            self.state.win_count += 1
        else:
            self.state.loss_count += 1
        
        # Remove from positions
        self.state.positions = [p for p in self.state.positions if p.id != position.id]
        
        self._save_state()
        self.logger.info(f"Position closed: {position.symbol} {reason} PnL: ${pnl:.2f}")
    
    def get_stats(self) -> Dict[str, Any]:
        """Get agent statistics"""
        total_trades = self.state.win_count + self.state.loss_count
        win_rate = (self.state.win_count / total_trades * 100) if total_trades > 0 else 0
        
        return {
            'agent_id': self.agent_id,
            'name': self.name,
            'enabled': self.enabled,
            'total_trades': total_trades,
            'win_count': self.state.win_count,
            'loss_count': self.state.loss_count,
            'win_rate': win_rate,
            'total_pnl': self.state.total_pnl,
            'open_positions': len(self.state.positions),
            'last_signal': self.state.last_signal_time
        }
    
    def enable(self):
        """Enable the agent"""
        self.enabled = True
        self.state.enabled = True
        self._save_state()
    
    def disable(self):
        """Disable the agent"""
        self.enabled = False
        self.state.enabled = False
        self._save_state()
